<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>m | succinct, expressive and efficient programming</title>
		<link rel="stylesheet" href="simple.css">
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<header>
		<nav>
			<a href="/">M</a>
			<a href="/tutorial/general.html">Tutorials</a>
			<a href="/grammar.html" class="current">Grammar</a>
            <a href="https://github.com/ligangwang/m"><svg class="icon" viewBox="0 0 32 32">
                    <path
                        d="M16 0.395c-8.836 0-16 7.163-16 16 0 7.069 4.585 13.067 10.942 15.182 0.8 0.148 1.094-0.347 1.094-0.77 0-0.381-0.015-1.642-0.022-2.979-4.452 0.968-5.391-1.888-5.391-1.888-0.728-1.849-1.776-2.341-1.776-2.341-1.452-0.993 0.11-0.973 0.11-0.973 1.606 0.113 2.452 1.649 2.452 1.649 1.427 2.446 3.743 1.739 4.656 1.33 0.143-1.034 0.558-1.74 1.016-2.14-3.554-0.404-7.29-1.777-7.29-7.907 0-1.747 0.625-3.174 1.649-4.295-0.166-0.403-0.714-2.030 0.155-4.234 0 0 1.344-0.43 4.401 1.64 1.276-0.355 2.645-0.532 4.005-0.539 1.359 0.006 2.729 0.184 4.008 0.539 3.054-2.070 4.395-1.64 4.395-1.64 0.871 2.204 0.323 3.831 0.157 4.234 1.026 1.12 1.647 2.548 1.647 4.295 0 6.145-3.743 7.498-7.306 7.895 0.574 0.497 1.085 1.47 1.085 2.963 0 2.141-0.019 3.864-0.019 4.391 0 0.426 0.288 0.925 1.099 0.768 6.354-2.118 10.933-8.113 10.933-15.18 0-8.837-7.164-16-16-16z">
                    </path>
                </svg>Github</a>
		</nav>
		</header>
		<h3>m grammar</h3>
<pre>
# grammar for mlang
# This is the actual grammar text consumed by self-developed LALR parser generator pgen 
# to output a parsing table for mlang parser to parse m source code into ASTs. 
# The right side of each production rule enclosed by curly parentheses is semantic action in 
# generating AST tree when the rule is applied to reduce to left symbol of the grammar rule.

start           = statements                                                               

unit_expr       = "()"
type_expr       = IDENT
                | unit_expr
                | '&' IDENT                                                                 { unop 0 1 }

primary_expr    = INT                                                                 
                | DOUBLE                                                               
                | IDENT                                                               
                | CHAR                                                                
                | STRING                                                              
                | "true"                                                              
                | "false"                                                             
                | '(' expr ')'                                                              { 1 }

postfix_expr    = primary_expr
                | postfix_expr '[' expr ']'                                                 { indexing 0 2 }
                | struct_init                                                           
                | postfix_expr '.' IDENT                                                    { indexing 0 2 } 
                | func_call
                | postfix_expr "++"                                                         { unop 1 0 } # the disorder of operator and operand indicates a postfix op
                | postfix_expr "--"                                                         { unop 1 0 }

power_expr      = postfix_expr "**" unary_expr                                              { binop 0 1 2 } 
                | postfix_expr                                                        

unary_expr      = power_expr                                                          
                | "++" unary_expr                                                           { unop 0 1 }
                | "--" unary_expr                                                           { unop 0 1 }
                | [*&+-~!] unary_expr                                                       { unop 0 1 }

#next should be cast_expr 


multi_expr      = unary_expr
                | multi_expr [*/%] unary_expr                                               { binop 0 1 2 } 

add_expr        = add_expr [+-] multi_expr                                                  { binop 0 1 2 } 
                | multi_expr

shift_expr      = add_expr
                | shift_expr "<<"  add_expr                                                 { binop 0 1 2 }
                | shift_expr ">>"  add_expr                                                 { binop 0 1 2 }

relation_expr   = shift_expr                                                            
                | relation_expr '<' shift_expr                                              { binop 0 1 2 }
                | relation_expr '>' shift_expr                                              { binop 0 1 2 }
                | relation_expr "<=" shift_expr                                             { binop 0 1 2 }
                | relation_expr ">=" shift_expr                                             { binop 0 1 2 }

eq_expr         = relation_expr
                | eq_expr "==" relation_expr                                                { binop 0 1 2 }
                | eq_expr "!=" relation_expr                                                { binop 0 1 2 }

bit_and_expr    = eq_expr                                                       
                | bit_and_expr '&' eq_expr                                                  { binop 0 1 2 }

bit_xor_expr    = bit_and_expr                                                        
                | bit_xor_expr '^' bit_and_expr                                             { binop 0 1 2 }

bit_or_expr     = bit_xor_expr                                                        
                | bit_or_expr '|' bit_xor_expr                                              { binop 0 1 2 }

logic_and_expr  = bit_or_expr
                | logic_and_expr "&&" bit_or_expr                                           { binop 0 1 2 }

logic_or_expr   = logic_and_expr
                | logic_or_expr "||" logic_and_expr                                         { binop 0 1 2 }

cond_expr       = logic_or_expr
                | logic_or_expr '?' expr ':' cond_expr

assign_expr     = cond_expr
                | unary_expr assign_op  assign_expr                                         { binop 0 1 2 }

assign_op       = '='
                | "*="
                | "/="
                | "%="
                | "+="
                | "-="
                | "<<="
                | ">>="
                | "&="
                | "^="
                | "|="

expr            = assign_expr

stmt            = func_type
                | func_def                                                            
                | type_def                                                            
                | expr                                                                
                | var_decls                                                           
                | iterate_stmt                   
                | cond_stmt    
                | block
                | import_decl

cond_stmt       = "if" expr "then" statement                                                { if_cond 1 3 }              
                | "if" expr "then" statement "else" statement                               { if_cond 1 3 5 }

# stmt and newline if it exists
statement       = stmt
                | stmt NEWLINE

block           = NEWLINE INDENT statements DEDENT                                          { 2 }
statements      = statements statement                                                      { block 0 1 }
                | statement                                                                 { block 0 }                                                     

type_def        = "enum" IDENT '=' statement                                                { enum_def 1 3 }
                | "struct" IDENT '=' statement                                              { struct_def 1 3 }
                | "union" IDENT '=' statement                                               { union_def 1 3 }

struct_init     = IDENT '(' exprs ')'                                                       { struct_init 0 2 }

func_type       = "fun" IDENT param_decls "->" type_expr                                    { func_type 1 4 2 }

import_decl     = "from" IDENT "import" memory_decl                                         { import_decl 1 3 }
                | "from" IDENT "import" func_type                                           { import_decl 1 3 }    
                | "from" IDENT "import" var_decl                                            { import_decl 1 3 }

memory_decl     = "memory" INT                                                              { memory_decl 1 }
                | "memory" INT ',' INT                                                      { memory_decl 1 3 }

func_def        = "let" IDENT param_decls '=' statement                                     { func 1 2 4 }
                | "let" IDENT ':' type_expr param_decls '=' statement                       { func 1 4 6 3 }

func_call       = IDENT arg_exprs                                                           { call 0 1 }

arg_exprs       = arg_exprs primary_expr                                                    { block 0 1 }
                | primary_expr                                                              { block 0 }
                | unit_expr                                                                 { block }  # empty block

exprs           = exprs ',' expr                                                            { block 0 2 }
                | expr                                                                      { block 0 }

iterate_stmt    = "for" param_decl "in" expr ".." expr ".." expr block                      { for_loop 1 3 5 7 8 }
                | "for" param_decl "in" expr ".." expr block                                { for_loop 1 3 5 6 }

param_decls     = param_decls param_decl                                                    { block 0 1 }
                | param_decl                                                                { block 0 }
                | unit_expr                                                                 { block }  # empty block

var_decls       = var_decls ',' var_decl                                                    { block 0 2 }
                | var_decl

param_decl      = IDENT ':' type_expr                                                       { var 0 0 2 } # var name:type, no initial value
                | IDENT                                                                     { var 0 0 } # value name, no type, no initial value
                | "..."

var_decl        = IDENT ':' type_expr                                                       { var 0 0 2 }   # var name:type, no initial value
                | IDENT ':' type_expr '=' expr                                              { var 1 0 2 4 } # var name:type with init value
                | IDENT '=' expr                                                            { var 1 0 2 }   # var name with initial value
            
              
</pre>
<footer>
	<p>mlang is created by <a href="https://wangs.dev">Ligang Wang</a> and is open sourced under the MIT license.</p>
</footer>
	</body>
</html>