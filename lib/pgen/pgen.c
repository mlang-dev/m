#include <stdio.h>
#include <stdlib.h>

#include "pgen/lalr_parser_generator.h"
#include <assert.h>
#include "clib/symbol.h"
#include "clib/util.h"
#include "lexer/lang_token.h"
#include "lexer/lexer.h"
#include "parser/node_type.h"
#include "sema/type.h"
#include "clib/util.h"
#include "app/error.h"
#include "app/app.h"


#define header_comment_template  "/*\n"\
                              " * parsing table for parser\n"\
                              " * DO NOT edit this file, this file is generated by pgen\n"\
                              " * \n"\
                              " * Copyright (C) 2022 Ligang Wang <ligangwangs@gmail.com>\n"\
                              " *     \n"\
                              " */    \n"

#define header_file_template    "#define PARSING_RULE_COUNT %d\n"\
                                "#define PARSING_STATE_COUNT %d\n"\
                                "#define PARSING_SYMBOL_COUNT %d\n"

#define source_header_template   "#define M_PARSING_INITIALIZER 1\n"\
                                 "#include \"parser/parsing_table.h\"\n\n"

#define source_parsing_symbols_initializer "const char *m_parsing_symbols[PARSING_SYMBOL_COUNT] = {\n"
#define source_parsing_rules_initializer "const struct parse_rule m_parsing_rules[PARSING_RULE_COUNT] = {\n"
#define source_parsing_states_initializer "struct parse_state_items m_parsing_states[PARSING_STATE_COUNT] = {\n"
#define source_parsing_table_initializer "const struct parser_action m_parsing_table[PARSING_STATE_COUNT][PARSING_SYMBOL_COUNT] = {\n"
#define source_data_initializer_end  "};\n"

const char *parsing_actions[] = {
    "E",
    "S",
    "R",
    "A",
    "G"
};

int write_to_header_file(struct lalr_parser_generator *pg, const char *header_path)
{
    FILE *f = fopen(header_path, "w");
    if(f == NULL){
        printf("Error opening header file: %s\n", header_path);
        exit(1);
    }
    fprintf(f, header_comment_template);
    fprintf(f, header_file_template, pg->rule_count, pg->parse_state_count, get_lang_symbol_count());
    fclose(f);
    return 0;
}

string to_rule_string(struct parse_rule *rule, int dot)
{
    string str;
    string_init(&str);
    string_add(&str, get_lang_symbol_by_index(rule->lhs));
    string_add_chars(&str, " = ");
    for (int i = 0; i < rule->symbol_count; i++) { // rhs
        if (dot == i){
            string_add_chars(&str, ".");
        }
        string_add(&str, get_lang_symbol_by_index(rule->rhs[i]));
        if(i < rule->symbol_count - 1){
            string_add_chars(&str, " ");
        }
    }
    if(dot == rule->symbol_count){
        string_add_chars(&str, ".");
    }
    return str;
}

void print_rule(FILE * f, struct parse_rule * rule)
{
    // struct parse_rule {
    /*
    const char *rule_grammar;
    u16 lhs; // non terminal symbol index
    u16 rhs[MAX_SYMBOLS_RULE]; // right hand side of production rule
    u8 symbol_count; // right side of
    struct semantic_action action;
    */
    //{ 0, { 0, 0, 0, 0, 0, 0, 0 }, 0, { 0, { 0, 0, 0, 0, 0 }, 0 } }
    int i;
    string rule_string = to_rule_string(rule, -1);
    fprintf(f, "{\"%s\", %d,{", string_get(&rule_string), rule->lhs); // lhs
    string_deinit(&rule_string);
    for (i = 0; i < MAX_SYMBOLS_RULE; i++) { // rhs
        fprintf(f, "%d,", rule->rhs[i]);
    }
    fprintf(f, "},");
    fprintf(f, "%d,", rule->symbol_count); // symbol count
    // rule action
    fprintf(f, "{%d,", rule->action.node_type);
    fprintf(f, "{"); // index array
    for (i = 0; i < MAX_SYMBOLS_RULE; i++) {
        fprintf(f, "%d,", rule->action.item_index[i]);
    }
    fprintf(f, "},"); // end of index array
    fprintf(f, "%d", rule->action.item_index_count); // total index
    fprintf(f, "}"); // end of action
    fprintf(f, "},"); // end of rule
}

void print_state_string(FILE *f, struct parse_rule *rules, struct parse_state *state)
{
    struct parse_item_list_entry *entry;
    struct parse_item *item;
    //struct index_list_entry *la_entry;
    u8 i = 0;
    fprintf(f, "{%d, {", state->kernel_item_count);
    list_foreach(entry, &state->items)
    {
        assert(state->kernel_item_count < MAX_KERNEL_ITEMS);
        if (i >= state->kernel_item_count)
            break;
        item = &entry->data;
        string rule_str = to_rule_string(&rules[item->rule], item->dot);
        fprintf(f, "{%d, %d, \"%s\"}, ", item->rule, item->dot, string_get(&rule_str));
        string_deinit(&rule_str);
        i++;
    }
    fprintf(f, "}},\n");
}

void print_parsing_table_row(FILE * f, struct parser_action * actions, u16 action_count)
{
    fprintf(f, "{");
    for (u16 i = 0; i < action_count; i++) {
        fprintf(f, "{%s,%d},", parsing_actions[actions[i].code], actions[i].state_index);
    }
    fprintf(f, "},");
}

int write_to_source_file(struct lalr_parser_generator * pg, const char *source_path)
{
    u16 i;
    struct parse_rule *rule;
    struct parser_action (*parsing_table)[MAX_STATES][MAX_GRAMMAR_SYMBOLS] = (struct parser_action (*)[MAX_STATES][MAX_GRAMMAR_SYMBOLS])pg->parsing_table;
    FILE *f = fopen(source_path, "w");
    if (f == NULL) {
        printf("Error opening source file: %s\n", source_path);
        exit(1);
    }
    fprintf(f, header_comment_template);
    fprintf(f, source_header_template);
    fprintf(f, source_parsing_symbols_initializer);
    symbol sym;
    for (i = 0; i < get_lang_symbol_count(); i++) {
        sym = get_lang_symbol_by_index(i);
        fprintf(f, "  /*symbol %3d*/ ", i); // comments
        fprintf(f, "\"%s\",\n", string_cstr(sym));
    }
    fprintf(f, source_data_initializer_end);
    fprintf(f, "\n");
    fprintf(f, source_parsing_rules_initializer);
    // print all rule data
    fprintf(f, "/* all rules */\n");
    for (i = 0; i < pg->rule_count; i++) {
        //    /*rule 0*/ { 0, { 0, 0, 0, 0, 0, 0, 0 }, 0, { 0, { 0, 0, 0, 0, 0 }, 0 } }
        fprintf(f, "  /*rule %3d*/ ", i); // comments
        rule = &pg->parse_rules[i];
        print_rule(f, rule);
        fprintf(f, "\n");
    }
    fprintf(f, source_data_initializer_end);
    fprintf(f, "\n");

    fprintf(f, source_parsing_states_initializer);
    for (i = 0; i < pg->parse_state_count; i++) {
        fprintf(f, "  /*state %3d*/ ", i); // comments
        print_state_string(f, pg->parse_rules, &pg->parse_states[i]);
    }
    fprintf(f, source_data_initializer_end);
    fprintf(f, "\n");

    fprintf(f, source_parsing_table_initializer);
    for (i = 0; i < pg->parse_state_count; i++) {
        // print one state
        fprintf(f, "  /*state %3d*/ ", i);
        // print row
        print_parsing_table_row(f, (*parsing_table)[i], get_lang_symbol_count());
        fprintf(f, "\n");
    }
    fprintf(f, source_data_initializer_end);
    fclose(f);
    return 0;
}

void pgen_init()
{
    app_init();
    node_type_init();
    lang_token_init();
}

void pgen_deinit()
{
    pgen_token_deinit();
    node_type_deinit();
    app_deinit();
}

void copy_file(const char *src, const char *dest) {
    FILE *src_file = fopen(src, "rb");
    FILE *dest_file = fopen(dest, "wb");
    
    if (src_file == NULL || dest_file == NULL) {
        printf("Error opening file.\n");
        return;
    }
    
    char buffer[1024];
    size_t bytes_read;
    
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), src_file)) > 0) {
        fwrite(buffer, 1, bytes_read, dest_file);
    }
    
    fclose(src_file);
    fclose(dest_file);
}

void copy_directory(const char *source_folder, const char *dest_folder) {
    char command[1024];
    snprintf(command, sizeof(command), "cp -r %s %s", source_folder, dest_folder);
    system(command);
}

void write_to_file(const char *content, const char *filepath)
{
    FILE *f = fopen(filepath, "w");
    if (f == NULL) {
        printf("Error opening file: %s\n", filepath);
        exit(1);
    }
    fprintf(f, "%s", content);
    fclose(f);
}

void process_token_file(const char *token_name, const char *keyword_or_operator, const char *lang_name, const char *source_folder, const char *header_folder)
{
    char token_filepath[1024];
    sprintf(token_filepath, "%spgen/%s/%s_%s.pgn", source_folder, lang_name, lang_name, keyword_or_operator);
    char token_keyword_headerpath[1024];
    sprintf(token_keyword_headerpath, "%slexer/%s/%s_token.%s", header_folder, lang_name, lang_name, keyword_or_operator);
    char token_keyword_sourcepath[1024];
    sprintf(token_keyword_sourcepath, "%slexer/%s/%s_token.%s.def", source_folder, lang_name, lang_name, keyword_or_operator);

    const char *token_keyword = read_text_file((const char*)token_filepath);
    //copy token keyword file to lexer folder and rename it to token.keyword.def
    write_to_file(token_keyword, token_keyword_sourcepath);
    //generate token.keyword header file
    FILE *f = fopen(token_keyword_headerpath, "w");
    fprintf(f, "/*** DO NOT edit this file, this file is generated by pgen ***/\n");
    struct lexer *lexer = lexer_new_with_string(token_keyword);
    struct token *tok = get_tok(lexer);
    while(tok->token_type != TOKEN_EOF && tok->token_type != TOKEN_NULL){
        while(tok->token_type == TOKEN_INDENT || tok->token_type == TOKEN_DEDENT){
            tok = get_tok(lexer);
        }
        while(tok->token_type == TOKEN_NEWLINE){
            fprintf(f, "\n");
            tok = get_tok(lexer);
        } 
        //write to header file pointed by token_keyword_headerpath
        if(tok->token_type == TOKEN_IDENT){
            tok = get_tok(lexer);
            assert(tok->token_type == TOKEN_LPAREN);
            tok = get_tok(lexer);
            assert(tok->token_type == TOKEN_IDENT);
            fprintf(f, "\t%s_%s,", token_name, string_get(tok->symbol_val));
            while(tok->token_type != TOKEN_NEWLINE && tok->token_type != TOKEN_EOF){
                //skip to the end of line
                tok = get_tok(lexer);
            }
        }
        while(tok->token_type == TOKEN_NEWLINE){
            fprintf(f, "\n");
            tok = get_tok(lexer);
        }
    }
    fclose(f);
    lexer_free(lexer);
    free((void*)token_keyword);
}

int generate_files(const char *lang_name,
    const char *header_folder, const char *source_folder)
{
    pgen_init();
    char file_path[1024];
    sprintf(file_path, "%spgen/%s/%s_grammar.pgn", source_folder, lang_name, lang_name);
    printf("parsing grammar file %s ...\n", file_path);
    char header_filepath[1024];
    sprintf(header_filepath, "%sparser/%s/%s_parsing_table.h", header_folder, lang_name, lang_name);
    char source_filepath[1024];
    sprintf(source_filepath, "%sparser/%s/%s_parsing_table.c", source_folder, lang_name, lang_name);
    const char *grammar = read_text_file(file_path);
    sprintf(file_path, "%spgen/%s/%s_keyword.pgn", source_folder, lang_name, lang_name);
    const char *token_text = read_text_file(file_path);
    sprintf(file_path, "%spgen/%s/%s_operator.pgn", source_folder, lang_name, lang_name);
    const char *op_text = read_text_file(file_path);

    struct lalr_parser_generator *pg = lalr_parser_generator_new(grammar, token_text, op_text);
    
    printf("generating %s ...\n", header_filepath);
    write_to_header_file(pg, header_filepath);
    printf("generating %s ...\n", source_filepath);
    write_to_source_file(pg, source_filepath);
    lalr_parser_generator_free(pg);

    //copy /include/pgen/def to /include/parser/def
    sprintf(header_filepath, "%sparser/parser_def.h", header_folder);
    char pgen_header_folder[1024];
    sprintf(pgen_header_folder, "%spgen/parser_def.h", header_folder);
    copy_file(pgen_header_folder, header_filepath);

    //process /lib/pgen/m_token.keyword.pgn
    process_token_file("TOKEN", "keyword", lang_name, source_folder, header_folder);
    //process /lib/pgen/m_token.operator.pgn
    process_token_file("OP", "operator", lang_name, source_folder, header_folder);
    
    free((void *)grammar);
    free((void *)token_text);
    free((void *)op_text);
    pgen_deinit();
    return 0;
}

int main(int argc, char *argv[])
{
    if (argc != 4) {
        printf("pgen usage is: pgen lang_name header_path(.h) source_path(.c)\n");
    }
    printf("welcome to pgen!\n");
    return generate_files(argv[1], argv[2], argv[3]);
}
