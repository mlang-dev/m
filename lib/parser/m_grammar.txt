/*
 * grammar for mlang
 * This is the actual grammar text consumed by self-developed LALR parser generator pgen 
 * to output a parsing table for mlang parser to parse m source code into ASTs. 
 * The right side of each production rule enclosed by curly parentheses is semantic action in 
 * generating AST tree when the rule is applied to reduce to left symbol of the grammar rule.
*/

start           = statements                                                               

unit_expr       = "()"

type_expr       = IDENT                                                                     { type_node 1 0 } // 1 is type name
                | unit_expr                                                                 { type_node 0 0 } // 0 is unit type
                | array_type                                                                { type_node 2 0 } // 2 is array type
                | '&' type_expr                                                             { type_node 3 1 }  
                | "mut" type_expr                                                           { mark_mut 1 1 1 } // 1 is action code for mark_mut for type node

array_type      = type_expr array_dims                                                      { array_type 0 1 }

array_dims      = '[' const_expr ']'                                                        { block 1 }
                | array_dims '[' const_expr ']'                                             { block 0 2 }

literal_expr    = INT                                                                 
                | DOUBLE                                                               
                | CHAR                                                                
                | STRING                                                              
                | "true"                                                              
                | "false"                                                             

primary_expr    = literal_expr                                             
                | IDENT                                                               
                | '(' expr ')'                                                              { 1 }

postfix_expr    = primary_expr
                | postfix_expr '[' expr ']'                                                 { indexing 0 0 2 } //first zero indicates left is array
                | adt_initializer                                                           
                | postfix_expr '.' IDENT                                                    { indexing 1 0 2 } // first one indicates left is struct
                | func_call
                | postfix_expr "++"                                                         { unop 1 0 } // the disorder of operator and operand indicates a postfix op
                | postfix_expr "--"                                                         { unop 1 0 }

power_expr      = postfix_expr "**" unary_expr                                              { binop 0 1 2 } 
                | postfix_expr                                                        

unary_expr      = power_expr                                                          
                | "++" unary_expr                                                           { unop 0 1 }
                | "--" unary_expr                                                           { unop 0 1 }
                | "|/" unary_expr                                                           { unop 0 1 }
                | [*&+-~!] unary_expr                                                       { unop 0 1 }

cast_expr       = unary_expr
                | '(' type_expr ')' cast_expr                                               { cast 1 3 }

multi_expr      = cast_expr
                | multi_expr [*/%] cast_expr                                                { binop 0 1 2 } 

add_expr        = add_expr [+-] multi_expr                                                  { binop 0 1 2 } 
                | multi_expr

shift_expr      = add_expr
                | shift_expr "<<"  add_expr                                                 { binop 0 1 2 }
                | shift_expr ">>"  add_expr                                                 { binop 0 1 2 }

relation_expr   = shift_expr                                                            
                | relation_expr '<' shift_expr                                              { binop 0 1 2 }
                | relation_expr '>' shift_expr                                              { binop 0 1 2 }
                | relation_expr "<=" shift_expr                                             { binop 0 1 2 }
                | relation_expr ">=" shift_expr                                             { binop 0 1 2 }

eq_expr         = relation_expr
                | eq_expr "==" relation_expr                                                { binop 0 1 2 }
                | eq_expr "!=" relation_expr                                                { binop 0 1 2 }

bit_and_expr    = eq_expr                                                       
                | bit_and_expr '&' eq_expr                                                  { binop 0 1 2 }

bit_xor_expr    = bit_and_expr                                                        
                | bit_xor_expr '^' bit_and_expr                                             { binop 0 1 2 }

bit_or_expr     = bit_xor_expr                                                        
                | bit_or_expr '|' bit_xor_expr                                              { binop 0 1 2 }

logic_and_expr  = bit_or_expr
                | logic_and_expr "&&" bit_or_expr                                           { binop 0 1 2 }

logic_or_expr   = logic_and_expr
                | logic_or_expr "||" logic_and_expr                                         { binop 0 1 2 }

cond_expr       = logic_or_expr
                | logic_or_expr '?' expr ':' cond_expr                                      { if_cond 0 2 4 }

const_expr      = cond_expr

assignee_expr   = cond_expr
                | array_init

assign_expr     = assignee_expr
                | unary_expr assign_op  assign_expr                                         { assign 0 1 2 }

assign_op       = '='
                | "*="
                | "/="
                | "%="
                | "+="
                | "-="
                | "<<="
                | ">>="
                | "&="
                | "^="
                | "|="

expr            = assign_expr
                | match_expr

array_init      = '[' array_init_decl ']'                                                   { array_init 1 }
                | '[' ']'                                                                   { array_init }

array_init_decl = range_expr
                | for_stmt
                | expr_list

expr_list       = expr_list ',' expr                                                        { block 0 2 }
                | expr                                                                      { block 0 }

stmt            = func_type
                | func_def                                                            
                | type_def                                                            
                | expr                                                                
                | var_decls                                                           
                | for_stmt                   
                | while_stmt
                | cond_stmt    
                | block
                | import_decl
                | jump_stmt

jump_stmt       = "continue"                                                                { jump 0 }
                | "break"                                                                   { jump 0 }
                | "return"                                                                  { jump 0 }
                | "return" expr                                                             { jump 0 1 }

cond_stmt       = "if" expr "then" statement                                                { if_cond 1 3 }              
                | "if" expr "then" statement "else" statement                               { if_cond 1 3 5 }

match_expr      = "match" expr "with" NEWLINE match_block_lines                             { match_expr 1 4 }

match_block_lines   = match_block_lines match_block_line                                    { block 0 1 }
                    | match_block_line                                                           

match_block_line    = '|' match_case                                                        { 1 }
                    | '|' match_case NEWLINE                                                { 1 }

match_case      = pattern  "->" expr                                                        { match_case 0 2 }
                | pattern "when" cond_expr "->" expr                                        { match_case 0 2 4 }

pattern         = IDENT              //variable pattern     
                | '-' literal_expr                                                          { unop 0 1 }
                | literal_expr       //constant pattern
                | '_'                                                                       { wild_card }//wildcard pattern                     

// stmt and newline if it exists
statement       = stmt
                | stmt NEWLINE

block           = NEWLINE INDENT statements DEDENT                                          { 2 }
statements      = statements statement                                                      { block 0 1 }
                | statement                                                                 { block 0 }                                                     

type_def            = "struct" IDENT '=' struct_type                                        { struct_type 1 3 }
                    | "union" IDENT '=' union_type                                          { union_type 1 3 }

struct_type         = id_decls
                    | NEWLINE INDENT field_decls_lines DEDENT                               { 2 }

field_decls_lines   = field_decls_lines field_decls_line                                    { block 0 1 }
                    | field_decls_line

field_decls_line    = id_decls 
                    | id_decls NEWLINE                                                     { 0 }

union_type          = union_items                  
                    | union_type_block

union_type_block    = NEWLINE INDENT union_item_lines DEDENT                                { 2 }
union_item_lines    = union_item_lines union_item_line                                      { block 0 1 }
                    | union_item_line                                                           

union_item_line     = '|' union_item                                                        { 1 }
                    | '|' union_item NEWLINE                                                { 1 }

union_items =       = union_items '|' union_item                                            { block 0 2 }
                    | union_item

union_item      = IDENT '(' type_list ')'                                                   { union_type_item 0 0 2 } //tagged union
                | IDENT ':' type_expr                                                       { union_type_item 1 0 2 } //untagged union
                | IDENT                                                                     { union_type_item 2 0 }   //enum
                | IDENT '=' INT                                                             { union_type_item 3 0 2 } //enum

type_list       = type_list ',' typed_item                                                  { block 0 2 }    
                | typed_item

typed_item      = IDENT ':' type_expr
                | type_expr

adt_initializer = IDENT '{' exprs '}'                                                       { adt_initializer 0 2 }
                | '{' exprs '}'                                                             { adt_initializer 1 }

func_type       = "fun" IDENT param_decls "->" type_expr                                    { func_type 1 4 2 }

import_decl     = "from" IDENT "import" memory_decl                                         { import_decl 1 3 }
                | "from" IDENT "import" func_type                                           { import_decl 1 3 }    
                | "from" IDENT "import" id_decl                                          { import_decl 1 3 }

memory_decl     = "memory" INT                                                              { memory_decl 1 }
                | "memory" INT ',' INT                                                      { memory_decl 1 3 }

func_def        = "let" IDENT param_decls '=' statement                                     { func 1 2 4 }
                | "let" IDENT ':' type_expr param_decls '=' statement                       { func 1 4 6 3 }

func_call       = IDENT arg_exprs                                                           { call 0 1 }

arg_exprs       = arg_exprs primary_expr                                                    { block 0 1 }
                | primary_expr                                                              { block 0 }
                | unit_expr                                                                 { block }  // empty block

exprs           = exprs ',' expr                                                            { block 0 2 }
                | expr                                                                      { block 0 }

for_stmt        = "for" param_decl "in" range_expr block                                    { for_loop 1 3 4 }

while_stmt      = "while" expr block                                                        { while_loop 1 2 }

range_expr      =  expr ".." expr ".." expr                                                 { range 0 2 4}
                |  expr ".." expr                                                           { range 0 2 }

param_decls     = param_decls param_decl                                                    { block 0 1 }
                | param_decl                                                                { block 0 }
                | unit_expr                                                                 { block }  // empty block

param_decl      = IDENT ':' type_expr                                                       { variable 0 0 2 } // var name:type, no initial value
                | IDENT                                                                     { variable 0 0 } // value name, no type, no initial value
                | "..."

var_decls       = "let" id_decl_inits                                                       { mark_mut 0 0 1 }
                | "var" id_decl_inits                                                       { mark_mut 0 1 1 }
                | "var" id_decls                                                            { mark_mut 0 1 1 }
  
id_decl_inits   = id_decl_inits ',' id_decl_init                                            { block 0 2 }
                | id_decl_init

id_decls        = id_decls ',' id_decl                                                      { block 0 2 }
                | id_decl

id_decl         = IDENT ':' type_expr                                                       { variable 0 0 2 }   // var name:type, no initial value

id_decl_init    = IDENT ':' type_expr '=' expr_block                                        { variable 1 0 2 4 } // var name:type with init value
                | IDENT '=' expr_block                                                      { variable 1 0 2 }   // var name with initial value

expr_block      = expr
                | NEWLINE INDENT expr DEDENT                                                { 2 }
