# grammar for mlang
# The right side of each production rule enclosed by curly parentheses is semantic action in 
# generating AST tree when the rule is applied to reduce to left symbol of the grammar rule.

start           = stmts                                                               

primary_expr    = INT                                                                 
                | FLOAT                                                               
                | IDENT                                                               
                | CHAR                                                                
                | STRING                                                              
                | "true"                                                              
                | "false"                                                             
                | '(' expr ')'                                                              { 1 }

postfix_expr    = primary_expr                                                        
                | func_call                                                           

power_expr      = postfix_expr "**" unary_expr                                              { binop 0 1 2 } # lhs op rhs
                | postfix_expr                                                        

unary_expr      = power_expr                                                          
                | [+-] unary_expr                                                           { unop 0 1 }

multi_expr      = unary_expr
                | multi_expr [*/%] unary_expr                                               { binop 0 1 2 } # lhs op rhs

add_expr        = add_expr [+-] multi_expr                                                  { binop 0 1 2 } # lhs op rhs
                | multi_expr

relation_expr   = add_expr                                                            
                | relation_expr '<' add_expr                                                { binop 0 1 2 }
                | relation_expr '>' add_expr                                                { binop 0 1 2 }
                | relation_expr "<=" add_expr                                               { binop 0 1 2 }
                | relation_expr ">=" add_expr                                               { binop 0 1 2 }
                | relation_expr "==" add_expr                                               { binop 0 1 2 }
                | relation_expr "!=" add_expr                                               { binop 0 1 2 }

bit_and_expr    = relation_expr                                                       
                | bit_and_expr '&' relation_expr                                            { binop 0 1 2 }

bit_xor_expr    = bit_and_expr                                                        
                | bit_xor_expr '^' bit_and_expr                                             { binop 0 1 2 }

bit_or_expr     = bit_xor_expr                                                        
                | bit_or_expr '|' bit_xor_expr                                              { binop 0 1 2 }

logic_and_expr  = bit_or_expr
                | logic_and_expr "&&" bit_or_expr                                           { binop 0 1 2 }

logic_or_expr   = logic_and_expr
                | logic_or_expr "||" logic_and_expr                                         { binop 0 1 2 }

expr            = logic_or_expr

block           = NEWLINE INDENT stmts DEDENT                                               { 2 }
block_or_stmt   = block                                                               
                | stmt                                                                      { block 0 }
stmts           = stmts NEWLINE stmt                                                        { block 0 2 }
                | stmts NEWLINE                                                             
                | stmt                                                                      { block 0 }

stmt            = func_def                                                            
                | type_def                                                            
                | expr                                                                
                | var_decls                                                           
                | iterate_stmt                   
                | cond_stmt    

cond_stmt       = "if" expr "then" block_or_stmt                                            { if_cond 1 3 }              
                | "if" expr "then" block_or_stmt "else" block_or_stmt                       { if_cond 1 3 5 }

type_def        = "type" IDENT '=' block_or_stmt                                            { type_def 1 3 }
func_def        = "let" IDENT param_decls '=' block_or_stmt                                 { func 1 2 4 }
func_call       = IDENT arg_exprs                                                           { call 0 1 }
arg_exprs       = arg_exprs primary_expr                                                    { block 0 1 }
                | primary_expr                                                              { block 0 }
                | '(' ')'                                                                   { block }  # empty block
    
iterate_stmt    = "for" param_decl "in" expr ".." expr ".." expr block                      { for_loop 1 3 5 7 8 }
                | "for" param_decl "in" expr ".." expr block                                { for_loop 1 3 5 6 }
param_decls     = param_decls param_decl                                                    { block 0 1 }
                | param_decl                                                                { block 0 }
                | '(' ')'                                                                   { block }  # empty block
var_decls       = var_decls ',' var_decl                                                    { block 0 1 }
                | var_decl                                                                  { block 0 }
param_decl      = IDENT ':' IDENT                                                           { var 0 0 2 } # var name:type, no initial value
                | IDENT                                                                     { var 0 0 } # value name, no type, no initial value
var_decl        = IDENT ':' IDENT                   { var 0 0 2 } # var name:type, no initial value
                | IDENT ':' IDENT '=' expr          { var 1 0 2 4 } # var name:type with init value
                | IDENT '=' expr                    { var 1 0 2 }   # var name with initial value
            
