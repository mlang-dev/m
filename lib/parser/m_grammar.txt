# grammar for mlang
# The right side of each production rule enclosed by curly parentheses is semantic action in 
# generating AST tree when the rule is applied to reduce to left symbol of the grammar rule.

start       = stmts                             { 0 }
block       = NEWLINE INDENT stmts DEDENT       { 2 }
            | stmt                              { block 0 }
stmts       = stmts NEWLINE stmt                { block 0 2 }
            | stmt                              { block 0 }
stmt        = func_def                          { 0 }
            | type_def                          { 0 }
            | expr                              { 0 }
            | var_decls                         { 0 }
            | EOF                               { 0 }
func_def    = IDENT param_decls '=' block       { func 0 1 3 }
#func_call   = IDENT arg_exprs                   { call 0 1 }
#arg_exprs   = arg_exprs expr                    { block 0 1 }
#            | expr                              { block 0 }
#            | '(' ')'                           { block }  # empty block
type_def    = "type" IDENT '=' block            { type_def 1 3 }
param_decls = param_decls param_decl            { block 0 1 }
            | param_decl                        { block 0 }
            | '(' ')'                           { block }  # empty block
var_decls   = var_decls var_decl                { block 0 1 }
            | var_decl                          { block 0 }
param_decl  = IDENT ':' IDENT                   { var 0 0 2 } # var name:type, no initial value
            | IDENT                             { var 0 0 } # value name, no type, no initial value
var_decl    = IDENT ':' IDENT                   { var 0 0 2 } # var name:type, no initial value
            | IDENT ':' IDENT '=' expr          { var 1 0 2 4 } # var name:type with init value
            | IDENT '=' expr                    { var 1 0 2 }   # var name with initial value
expr        = expr [+-] term                    { binop 0 1 2 } # lhs op rhs
            | term                              { 0 }
            | logic_val                         { 0 }
            | string_val                        { 0 }
term        = term [*/%] factor                 { binop 0 1 2 } # lhs op rhs
            | factor                            { 0 }
factor      = '(' expr ')'                      { 1 }
            | power                             { 0 }
            | [+-] factor                       { unop 0 1 }
power       = primary '^' factor                { binop 0 1 2 } # lhs op rhs
            | primary                           { 0 }
primary     = INT                               { 0 }
            | FLOAT                             { 0 }
            | IDENT                             { 0 }

logic_val   = "true"                            { 0 }
            | "false"                           { 0 }
            
string_val  = CHAR                              { 0 }
            | STRING                            { 0 }
