# grammar for mlang
# This is the actual grammar text consumed by self-developed LALR parser generator pgen 
# to output a parsing table for mlang parser to parse m source code into ASTs. 
# The right side of each production rule enclosed by curly parentheses is semantic action in 
# generating AST tree when the rule is applied to reduce to left symbol of the grammar rule.

start           = statements                                                               

unit_expr       = "()"
type_expr       = IDENT
                | unit_expr
                | '&' IDENT                                                                 { unop 0 1 }

primary_expr    = INT                                                                 
                | DOUBLE                                                               
                | IDENT                                                               
                | CHAR                                                                
                | STRING                                                              
                | "true"                                                              
                | "false"                                                             
                | '(' expr ')'                                                              { 1 }

postfix_expr    = primary_expr
                | postfix_expr '[' expr ']'                                                 { indexing 0 2 }
                | struct_init                                                           
                | postfix_expr '.' IDENT                                                    { indexing 0 2 } 
                | func_call
                | postfix_expr "++"                                                         { unop 1 0 } # the disorder of operator and operand indicates a postfix op
                | postfix_expr "--"                                                         { unop 1 0 }

power_expr      = postfix_expr "**" unary_expr                                              { binop 0 1 2 } 
                | postfix_expr                                                        

unary_expr      = power_expr                                                          
                | "++" unary_expr                                                           { unop 0 1 }
                | "--" unary_expr                                                           { unop 0 1 }
                | [*&+-~!] unary_expr                                                       { unop 0 1 }

#next should be cast_expr 


multi_expr      = unary_expr
                | multi_expr [*/%] unary_expr                                               { binop 0 1 2 } 

add_expr        = add_expr [+-] multi_expr                                                  { binop 0 1 2 } 
                | multi_expr

shift_expr      = add_expr
                | shift_expr "<<"  add_expr                                                 { binop 0 1 2 }
                | shift_expr ">>"  add_expr                                                 { binop 0 1 2 }

relation_expr   = shift_expr                                                            
                | relation_expr '<' shift_expr                                              { binop 0 1 2 }
                | relation_expr '>' shift_expr                                              { binop 0 1 2 }
                | relation_expr "<=" shift_expr                                             { binop 0 1 2 }
                | relation_expr ">=" shift_expr                                             { binop 0 1 2 }

eq_expr         = relation_expr
                | eq_expr "==" relation_expr                                                { binop 0 1 2 }
                | eq_expr "!=" relation_expr                                                { binop 0 1 2 }

bit_and_expr    = eq_expr                                                       
                | bit_and_expr '&' eq_expr                                                  { binop 0 1 2 }

bit_xor_expr    = bit_and_expr                                                        
                | bit_xor_expr '^' bit_and_expr                                             { binop 0 1 2 }

bit_or_expr     = bit_xor_expr                                                        
                | bit_or_expr '|' bit_xor_expr                                              { binop 0 1 2 }

logic_and_expr  = bit_or_expr
                | logic_and_expr "&&" bit_or_expr                                           { binop 0 1 2 }

logic_or_expr   = logic_and_expr
                | logic_or_expr "||" logic_and_expr                                         { binop 0 1 2 }

cond_expr       = logic_or_expr
                | logic_or_expr '?' expr ':' cond_expr

assign_expr     = cond_expr
                | unary_expr assign_op  assign_expr                                         { binop 0 1 2 }

assign_op       = '='
                | "*="
                | "/="
                | "%="
                | "+="
                | "-="
                | "<<="
                | ">>="
                | "&="
                | "^="
                | "|="

expr            = assign_expr
                | list_comp

list_comp       = '[' list_comp_decl ']'                                                    { list_comp 1 }
                | '[' ']'                                                                   { list_comp }

list_comp_decl  = range_expr
                | for_stmt
                | expr_list

expr_list       = expr                                                                      { block 0 }
                | expr_list ',' expr                                                        { block 0 2 }

stmt            = func_type
                | func_def                                                            
                | type_def                                                            
                | expr                                                                
                | var_decls                                                           
                | for_stmt                   
                | cond_stmt    
                | block
                | import_decl

cond_stmt       = "if" expr "then" statement                                                { if_cond 1 3 }              
                | "if" expr "then" statement "else" statement                               { if_cond 1 3 5 }

# stmt and newline if it exists
statement       = stmt
                | stmt NEWLINE

block           = NEWLINE INDENT statements DEDENT                                          { 2 }
statements      = statements statement                                                      { block 0 1 }
                | statement                                                                 { block 0 }                                                     

type_def        = "enum" IDENT '=' statement                                                { enum_def 1 3 }
                | "struct" IDENT '=' statement                                              { struct_def 1 3 }
                | "union" IDENT '=' statement                                               { union_def 1 3 }

struct_init     = IDENT '(' exprs ')'                                                       { struct_init 0 2 }

func_type       = "fun" IDENT param_decls "->" type_expr                                    { func_type 1 4 2 }

import_decl     = "from" IDENT "import" memory_decl                                         { import_decl 1 3 }
                | "from" IDENT "import" func_type                                           { import_decl 1 3 }    
                | "from" IDENT "import" var_decl                                            { import_decl 1 3 }

memory_decl     = "memory" INT                                                              { memory_decl 1 }
                | "memory" INT ',' INT                                                      { memory_decl 1 3 }

func_def        = "let" IDENT param_decls '=' statement                                     { func 1 2 4 }
                | "let" IDENT ':' type_expr param_decls '=' statement                       { func 1 4 6 3 }

func_call       = IDENT arg_exprs                                                           { call 0 1 }

arg_exprs       = arg_exprs primary_expr                                                    { block 0 1 }
                | primary_expr                                                              { block 0 }
                | unit_expr                                                                 { block }  # empty block

exprs           = exprs ',' expr                                                            { block 0 2 }
                | expr                                                                      { block 0 }

for_stmt        = "for" param_decl "in" range_expr block                                    { for_loop 1 3 4 }

range_expr      =  expr ".." expr ".." expr                                                 { range 0 2 4}
                |  expr ".." expr                                                           { range 0 2 }

param_decls     = param_decls param_decl                                                    { block 0 1 }
                | param_decl                                                                { block 0 }
                | unit_expr                                                                 { block }  # empty block

var_decls       = var_decls ',' var_decl                                                    { block 0 2 }
                | var_decl

param_decl      = IDENT ':' type_expr                                                       { var 0 0 2 } # var name:type, no initial value
                | IDENT                                                                     { var 0 0 } # value name, no type, no initial value
                | "..."

var_decl        = IDENT ':' type_expr                                                       { var 0 0 2 }   # var name:type, no initial value
                | IDENT ':' type_expr '=' expr                                              { var 1 0 2 4 } # var name:type with init value
                | IDENT '=' expr                                                            { var 1 0 2 }   # var name with initial value
